# Adding a New Contract File to the JavaScript Frontend

**One-liner Purpose**: Quickly generate gRPC-Web stubs for any newly added `.proto` definition so your frontend can seamlessly call the service methods.

## Steps to Integrate a New Proto File

1. **Place Your Proto File**  
   Put the new `.proto` (e.g. `myNewService.proto`) alongside your existing ones, typically in `collabTexteditorService/`.

2. **Update the Makefile**  
   In the Makefileâ€™s `generate-frontend-proto` target, add your `.proto` to `PROTO_SRC`. For example:
   ```makefile 
   PROTO_SRC := collabTexteditorService/collabTexteditorService.proto \
                collabTexteditorService/collabDiagrameditorService.proto \
                collabTexteditorService/myNewService.proto
    ```

3. **Run the Generation Command**
    From the project root ( where the makefile is placed ) run:
    ```makefile
    make generate-frontend-proto
    ```
    This uses protoc with the specified ```--proto_path``` and outputs generated Javascript code to your chosen OUT_DIR ( commomly ```frontend/src``` ).

4. **Locate the Generated Files**
    Once the make command is executed , 2 new files will be created:
    ```myNewService_pb.js```
    ```myNewService_grpc_web_pb.js```
    These appear in the frontend/src ( ow which directory specified in --js_out and --grpc-web_out tags)

5. **newServiceClient.js** 
    ```Purpose```: Handles all communication between your frontend and the gRPC-web service ( routed through an [envoy](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_web_filter#config-http-filters-grpc-web) server). Basically whenever the frontend UI needs to talk to the grpc-server (backend) for real-time collaboration (eg: ```sendLocalUpdate``` or ```subscribeForRemoteUpdates``` , it goes through the ```newServiceClient.js```)

6. **modelTransformer.js** 
    ```Purpose```: Bridges two different data representations:
    1. The proto message format generated by protoc ( i.e. ```TiTreeNode``` in the ```.proto```).
    2. The Local Javascript model ( ```TiTreeNode`` in the frontend code , can differ in structure/methods).

    This is kind of like a transformation layer , where one can use the response of the grpc api , and tranform it at the data structure level to be passed down to entire application. Provides more granular control over the grpc response and also obeys the contract layer.